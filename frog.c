#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>


//2. 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。
//如果n = 1，只有一种跳法，那就是1
//如果n = 2，那么有两种跳法，2，[1, 1]
//如果n = 3，那么有三种跳法，[1, 1, 1], , [1, 2], [2, 1]
//如果n = 4，那么有五种跳法，[1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2]
//如果n = 5，那么有八种跳法，[1, 1, 1, 1, 1], [1, 1, 1, 2], [1, 1, 2, 1], [1, 2, 1, 1], [2, 1, 1, 1], [2, 2, 1], [2, 1, 2], [1, 2, 2]
//结果为1，2，3，5，8  这不特么是斐波那切数列嘛
//递归做法：

int RJump1(int n)
{
	if (n == 0)
		return 0;
	if (n == 1)
		return 1;
	if (n == 2)
		return 2;
	//n>2
	return RJump1(n - 1) + RJump1(n - 2);
}


//非递归做法：

int  Jump1(int n)
{
	if (n == 0)
		return 0;
	if (n == 1)
		return 1;
	if (n == 2)
		return 2;
	int a1 = 1;
	int a2 = 2;
	int a3;
	for (int i = 3; i <= n; i++)
	{
		a3 = a1 + a2;
		a1 = a2;
		a2 = a3;
	}
	return a3;
}


//一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
//f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(n-(n-1)) + f(n-n)
//3. 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
//
//f(n) = f(n - 1) + f(n - 2) + f(n - 3) + ... + f(n - (n - 1)) + f(n - n) = f(0) + f(1) + f(2) + f(3) + ... + f(n - 2) + f(n - 1)
//f(n - 1) = f(0) + f(1) + f(2) + f(3) + ... + f((n - 1) - 1) = f(0) + f(1) + f(2) + f(3) + ... + f(n - 2)
//so  f(n) = 2 * f(n - 1)


int RJump2(int n)
{
	//台阶最小为1，此时为1次
	if (n == 1)
		return 1;
	//当阶数大于1时可以用递推公式
	return 2 * RJump2(n - 1);
}

//4. 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个m级的台阶总共有多少种跳法。
//先列多项式：
//f(n) = f(n - 1) + f(n - 2) + f(n - 3) + ... + f(n - m)
//f(n - 1) = f(n - 2) + f(n - 3) + ... + f(n - m) + f(n - m - 1)
//化简得：f(n) = 2f(n - 1) - f(n - m - 1)


//int RJump3(int n, int m)
//{
//	//当n==0即f(n-n)=f(0)，一次跳n阶只有一种跳法
//	if (m == 1||m==0)
//		return 1;
//	//当n小于m时可采用上述推到公式
//	if (n < m)
//	{
//		return 2 * RJump3(n, m-1) - RJump3(n , m - n - 1);
//	}
//	//当n大于m时可采用第二题的公式
//	
//	else
//	{
//		//注意此时传参，青蛙能跳的阶数最大只能为总的阶数,即m
//		return 2 * RJump3(m, m - 1);
//	}
//}


//n为总阶数，m为能跳的最大阶数
int RJump3(int n, int m)
{
	//
	if (n == 1)
		return 1;
	//当m小于n时可采用上述递推公式
	if (m < n)
	{
		return 2 * RJump3(n - 1, m) - RJump3(n - m, m);
	}

	//当m大于等于n时可采用第二题的公式
	else
	{
		//注意此时传参，青蛙能跳的阶数最大只能为总的阶数,即n
		return 2 * RJump3(n - 1, n);
	}
}


void test()
{
	printf("第一种的递归：%d\n", RJump1(4));
	printf("第一种的非递归：%d\n", Jump1(4));
	printf("第二种的递归：%d\n", RJump2(4));
	printf("第三种的递归，n>m：%d\n", RJump3(4, 3));
	printf("第三种的递归, n<m：%d\n", RJump3(3, 4));
}


int main()
{
	test();
	return 0;
}

